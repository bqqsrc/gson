gson需求
===

---
## gson待做需求
* 解决gson的opt里面的测试样例报错的问题
* 回调后置后，并不是每次回调的行号、偏移量都是准确的。例如有可能出现解析时回调key的时候，坐标已经偏移到具体的值了，这个时候就会报错误的行号和偏移量
* 解决bug：如果测试文件只有一个bool_1_1: true，会报错
* 解决bug：在两次执行newTargetInfo太快时，会导致拿到的时nil，复现：将newTargetInfo函数中的空值保护去掉，执行单元测试，可以出现，这个问题时因为decode_handler_test.go的Test_DecodeDataPrint和decode_test.go的测试样例Test_DecodeData导致的冲突而导致的bug，newParseInfo也有一样的问题
* 继续优化完善gson
1. 实现一个自动为struct生成Unmarshaler接口的工具（文本处理？运行时处理？，参考easyjson的gen怎么处理的）
2. 实现对复数等数据类型的转换
4. 实现gson的功能
5. 实现转换为gson的功能
7. decodetool的错误报错的测试
8. gson添加版本号可以扫描获取，没有设置版本号默认为1.0.0，首行#!gson1.0.0表示版本号
9. 实现整个解析为interface{}
10. 对中文的：！等符号做出警告处理
11. 添加变量定义截断key-value的定义的测试样例
12. 删除掉所有无用的require和replace，把需要冗余的测试样例集中一起测试
13. 实现标签构造符、替换构造符、占位符构造符的功能
14. 以单独一个键为目标获取值的方法取值，不需要解析整个文件，接下到了目标值就可以了
15. gson的测试文件改为按照根据系统确定换行符，不然每次换到mac系统就得进行一次换行操作
16. gson添加支持转为函数的类型，根据所获取的类型，获取到值之后调用该函数，返回其值
18. 将转为解析器的自动化功能实现（6个番茄）
   生成转换接口的逻辑：先文本扫描，确定出所有要添加转换接口的结构体名称、路径、包名等，然后创建一个临时文件，生成一个main函数，文本写入执行的代码，main函数遍历所有这些结构体，判断这些结构体是否都有对应的方法，如果没有，确定要生成的代码，然后生成临时文本，以tmp结尾，等到所有的代码生成完毕，把以tmp结尾的临时文件移到其对应的目录下，再次执行临时生成的main函数，检验是否所有结构体都生成了对应接口函数，生成成功后，再把临时main文件删除，这样就生成结束了。
19. 实现解析为Uintptr、Complex、Chan、Func、UnsafePointer的数据类型，解析为Pointer、Interface数据类型
20. 确定Lexer能否转为Uintptr、Complex、Chan、Func、UnsafePointer
21. 测试一下一个断言转换会耗时多长时间
22. 将SetUnmarshaler合并到SetAnyTarget中，待确定是否要做需求，需先充分测试到一次转换的性能损耗再进行确定
23. 实现解析整个文件为interface{}，待确定是否需要，如果是一个不知类型的interface{}，可能无法转换
24. 充分实现测试，性能测试
25. 将gson发布到git上面
26. 写gson的使用文档并发布到git上面
27. 写gson的实现文档
28. 实现gson的官方网站
29. 实现对指针、数组元素为指针、结构体成员为指针，且指向为nil的情况的解析，解析时生成一个新值，将指针的指向改为指向新值
30. gson可以解析嵌套的字典（对象），如果遇到重复的字段，则处理为数组（已安排）
* gson支持解析为指针数据时，允许指针初始值为nil，各种数据类型初始值为nil的解析
* gson支持解析为二维数组，多维数组，添加[]标记数组

---
## 其他非gson需求
1. 解决mac上无法git clone github上的项目的问题，1087端口被拒绝（是因为git设置了代理端口为1087，通过设置git的代理端口解决）
2. 了解以下unsafe，unsafe.Pointer，reflect.StringHeader，testing.AllocsPerRun，b.ReportAllocs，b.SetBytes，b.RunParallel，pb.Next
3. 将git pull，git push等操作写出一个固定脚本，开机自启动，这样可以把每天花在git操作上的时间省下来
4. 台式机安装go的各种调试工具，跳转工具等 
5. go什么叫做可寻址
6. windows机器和mac环境保持一致

---
## 已完成需求
* 添加回调接口的测试样例（排他性为true和false都要测试）（2023.1.6完成）
* 解决bug：当设置排他性为true时，还是会回调到对应的回调接口（2023.1.6完成）
* 添加其他各种测试样例（2023.1.6完成）
* 解决嵌套结构体、数组、字典的处理（2023.1.6完成）
   * 结构体嵌套
      * 结构体  ok   (12.31已完成)
      * 数组  ok   (12.31已完成)
      * 字典  ok  (12.31已完成)
   * 数组嵌套
      * 结构体  ok  (2023.1.1已完成)
      * 数组
      * 字典  ok   （2023.1.1已完成）
   * 字典嵌套
      * 结构体  ok   （2023.1.6完成）
      * 数组   ok   （2023.1.6完成）
      * 字典   ok    （2023.1.6完成）
* 穿插需求：先将gson的嵌套结构体、嵌套解析处理好，添加回调函数的测试样例，添加嵌套对象的测试样例（2023.1.6完成）
   * 遇见一个key，且当前不存在任何的parseInfo，那么就push一个parseInfo进去（12.29完成）
   * 遇见一个key，且存在非nil的parseInfo，reset这个parseInfo（12.29完成）
   * 遇见一个{，则push一个parseInfo的（12.29完成）
   * 遇见一个key，且当前存在非nil的target，且为非键的方式，那么就reset这个target（12.29完成）
   * 遇见一个key，且当前存在非nil的target，并且它的子target是一个struct、array、slice、map，那么就push一个target进去（2023.1.6完成）
* map的键支持非字符串类型的键
   将找到键的回到处理为返回l，而不是一整个的string
* 实现解析字典、数组、结构体、切片的相互嵌套的数据的解析（可以解析数组，嵌套字典，字典数组，切片以及其他go支持的基本数据类型（参考go的reflect包里面的数据）（2个番茄）） （2023.1.6完成）
   * basic的pop条件为find a key
   * 结构体中，发现结构体、要addsub，遇到}，如果当前是结构体，那么就要pop
   * 一个结构体如果发现一个key，且这个key为结构体，那么就要把这个新的结构体push进去
   * 当前为结构体，且发现一个}，那么就要把当前的结构体给pop出来
   * 一个结构体，如果发现一个key，且这个key为array，那么就要把这个数组push进去
   * 如果发现一个数组，那么就要把这个数组push进去，当遇到第i个值得回调时，就将第i个值赋值给这个数组
   * 如果在一个数组中发现了{，那么就要把这个结构体push进去，按照结构体来解析，当遇到}时就pop出来，如果发现上一级是一个数组，那么就把这个结构体赋值给这个数组
   * 一个map中，如果发现一个{，且他的类型是一个Struct或者map，那么就把它给push进去，当发现}结束了之后就pop出来  
	 * targetInfo添加一个fatherKey
   * 当发现一个新key时，如果确定了类型是struct、map时，则直接将对应的struct、map推入栈，如果是array、slice，则推数组入栈
   * 当发现一个{时，如果发现当前是一个struct、map时，则不推入任何东西入栈
   * 如果当前是一个array、slice时，且array和slice的数组元素时struct、map时，那么推struct、map入栈
   * 当发现}时，不管是什么类型，都推出栈，如果推出栈后，发现是一个数组元素，且类型对得上，那么将这个元素赋值给对象数组索引的值
   * 继续扫描
   * 当发现一个key时，如果当前是以索引赋值，则把当前推出栈
* 实现对map的解析（2023.1.6完成）
* 实现反射时struct的嵌套struct解析（2023.1.6完成）
* 如果把测试样例数据的testdata_map_arr注释掉，会报错:gson err: SetAnyTarget(nil, true/false); can't set a nil as target ;（这个是专门测试错误的测试样例报出来的错误，而非在testdata_map_arr时的报错）
* 解决bug：当设置排他性为true时，还是会回调到对应的回调接口（2023.1.6已完成）
* gson改为如果找不到值，不去修改原有的值，否则很多默认值都会被改掉（优先）（已安排）
* 添加一个找到一个值的回调，可以传key，可以传index，同时提供一个SetValue，为某一给target的下标或者key设置值，类似2个回调方法（优先）（已安排）
* gson要支持可以解析为目标对象的同时，还能够给出解析的回调，这样可以对某个对象解析为一个目标值，还可以在这个对象某个键的时候，传入一个新的值来解析。现有的实现是一旦传值了将不再进行回调（已安排）
* gson改为如果找不到值，不去修改原有的值，否则很多默认值都会被改掉（优先）
* 支持在解析为目标的同时，对一个值给出回调
* gson设计为：如果传入一个目标值了，那么就不能传入其他的目标值，但是可以回调到找到值得接口，这个改为可以配置的，传入true表示可以同时回调到其他，传入false则不可同时回调到其他
* 添加一个fatherkey，使用currentKey
* 实现对其他基本数据类型的解析转换（2个番茄）
* 测试一下直接.(type)判断类型和reflect判断类型的性能差异（已完成）（.(type)比reflect快了几十倍）
* 新增一个ConvertValue的值，可以传key，可以传index，同时提供一个SetValue，为某一给target的下标或者key设置值，类似2个回调方法（优先）（4个番茄）（已完成）
* 将基本类型转换也改成reflect转换的方式
* 实现对切片、数组以及其他基本go提供的数据类型的转换
* 先阅读lexer.go的实现（已完成）
* 实现一个存放临时字节流的buffer，可能是要结合lexer.go的（已完成）
* 实现一种基础类型的解析器接口（已完成）
* 实现一套基础类型的解析器模板（已完成）
* 实现所有基础类型的解析器接口（已完成）
* 实现一个struct的解析器接口（已完成）
* 设计测试样例，单独一串字符串就是一个值的处理方式，来测试UnmarshalAny和Unmarshal的基础类型
   有很多键的处理方式，来测试DecodeData的基本类型（已完成）
* 添加一个版本号的功能，将var在1.0.0屏蔽掉
* 将所有类型改为可选择生成，而不是全部生成，包括基本类型（基本类型已经完成了可选了）
* 添加获取单个键为目标值得方法
* 将enumV合并到floatV中（已完成）
* 修复bug：一种情况，如果结尾是一个强制字符串，没有空白符，会拿不到字符串的结尾（已解决）

---
## 取消需求
* 添加严格模式和宽松模式（现在是严格模式）（需求去掉）
