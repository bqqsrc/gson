学习日记
===

---
## 一些日记
UnknownV = iota //未知
	StringV     //字符串                     StringV
	NilV                 //空                StringV NilV
	BoolV                //布尔型            StringV BoolV
	FloatV               //浮点型            StringV FloatV 
	IntV                 //有符号整型        StringV IntV FloatV
	UintV                //无符号整型        StringV IntV FloatV UintV
	EnumV                //科学计算法数值     StringV FloatV
	ObjectV              //对象              
	VarstringV           //带占位符的字符串     StringV
	TagstringV                                 StringV


go自带的json解析
Unmarshal -> unmarshal ->
    rv := reflect.ValueOf(v)   //获取它的值，必需是一个指针且不为空
		d.scan.reset()   重置scanner
		d.scanWhile(scanSkipSpace)   //扫描知道不是空白跳过
		d.value   //将d转为rv   (rv是一个值，此时是一个指针)
		     d.array(v)  //将d现有数据以数组形式存入v，v就是上面的rv
				     u, ut, pv := indirect(v, false)   //v就是上面的v，即一开始的rv, u是转为Unmarshaler的，ut是转为TextUnmarshaler的，pv是转为其他值的
						    v0 := v
								haveArr := false
								v.Kind() != reflect.Pointer && v.Type().Name() != "" && v.CanAddr() {v = v.Addr(), haveArr = true}
								e := v.Elem()  v = e 直到v.Kind() != reflect.Pointer
								如果v是一种Unmarshaler，返回转为Unmarshaler的u, nil, reflect.Value{}  reflect.Value是一个空的Value结构体
								如果v是一种encoding.TextUnmarshaler，返回转为TextUnmarshaler的u
								如果v的haveAddr为true，返回原值，否则返回v.Elem
						 v = pv
						 switch v.Kind()  //检查目标类型
						    reflect.Interface  interface类型，设置值
								   arrayInterface   //将d转为数组
									    for (d.valueInterface)  //将d转为任何数值，存放到数组
									 valueInterface  //将d转为任何数值
									 objectInterface  //将d转为对象数值（就是map）
									 literalInterface  //将d转为普通数值
								reflect.Array, reflect.Slice类型								
						    
				 d.object(v)   //将d现有数据以对象形式存入v
				 d.literalStore(bytes, v, false)  //将指定的bytes以普通数值的形式存入v



		reflect.ValueOf(v).Kind()   //一个值的类型名称

		object是转换为struct的核心
		array是转换为数组的核心
		objectInterface是转换为map的核心

   v.Index(i)
	 v.Kind()
	 v.Elem()
	 v.Type()
	 v.CanAddr()
	 v.Addr()


rv := reflect.ValueOf(anyTarget)
if rv.Kind() == reflect.Pointer
re := rv.Elem()
if re.Kind() == reflect.Struct

ret := reflect.TypeOf(re)
rev := reflect.ValueOf(re)
for i := 0; i < ret.NumField()>
  
call
rv := reflect.ValueOf(anyTarget).Elem()
	

reflect.TypeOf(rev)和rev.Type()

### easyjson的gen的实现逻辑
easyjson生成源码的原理：
   easyjson作为入口，开始执行生成的逻辑
      获取所有要解析的文件
      for循环执行generate函数解析文件
          初始化一个parser.Parser类型，确定是否解析所有的结构体
          执行Parser的Parse函数开始解析
             扫描文件目录，确定出所有要解析的结构体所在的目录，go文件的功能
          根据生成的解析后的Parser类型，生成一个g，bootstrap.Generator类型
          执行g.Run
             调用writeStub写入对应结构体的go文件
             调用writeMain写入测试的main函数（gen是在writeMain时写入的，它的作用主要时用于解析，因此是先确定哪些需要解析，再生写入这些文件到go中，然后再go run测试）
             执行go run来生成对应的函数并测试

easyjson：生成源码的入口
parser：解析哪些文件需要生成源码的实现
bootstrap：生成源码是另一个main程序执行，这个main程序的go文件以及执行在bootstrap中实现
gen：解析结构体的代码